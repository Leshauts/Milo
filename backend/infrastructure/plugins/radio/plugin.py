"""
Plugin Radio pour Milo - Streaming web radio via mpv
"""
import asyncio
import logging
from typing import Dict, Any, Optional

from backend.infrastructure.plugins.base import UnifiedAudioPlugin
from backend.domain.audio_state import PluginState
from backend.infrastructure.plugins.radio.mpv_controller import MpvController
from backend.infrastructure.plugins.radio.radio_browser_api import RadioBrowserAPI
from backend.infrastructure.plugins.radio.station_manager import StationManager


class RadioPlugin(UnifiedAudioPlugin):
    """
    Plugin Radio pour Milo

    Suit le pattern des autres plugins (Librespot, Bluetooth, ROC):
    - Contr√¥le un service systemd externe (milo-radio.service avec mpv)
    - G√®re les m√©tadonn√©es (station actuelle, titre du stream)
    - Support multiroom et equalizer via routing service

    √âtats:
        INACTIVE ‚Üí service arr√™t√©
        READY ‚Üí service d√©marr√© (mpv en idle)
        CONNECTED ‚Üí station en cours de lecture
    """

    def __init__(self, config: Dict[str, Any], state_machine=None, settings_service=None):
        super().__init__("radio", state_machine)

        self.config = config
        self.service_name = config.get("service_name", "milo-radio.service")
        self.ipc_socket_path = config.get("ipc_socket", "/tmp/milo-radio-ipc.sock")
        self.settings_service = settings_service

        # Composants
        self.mpv = MpvController(self.ipc_socket_path)
        self.station_manager = StationManager(settings_service, state_machine)
        # Note: station_manager est pass√© √† RadioBrowserAPI pour fusionner stations personnalis√©es
        self.radio_api = RadioBrowserAPI(cache_duration_minutes=60, station_manager=self.station_manager)

        # √âtat actuel
        self.current_station: Optional[Dict[str, Any]] = None
        self._is_playing = False
        self._is_buffering = False
        self._metadata = {}
        self._current_device = "milo_radio"

        # Monitoring task
        self._monitor_task: Optional[asyncio.Task] = None
        self._stopping = False

    async def _do_initialize(self) -> bool:
        """Initialisation du plugin Radio"""
        try:
            # V√©rifier que le service existe
            proc = await asyncio.create_subprocess_exec(
                "systemctl", "list-unit-files", self.service_name,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, _ = await proc.communicate()

            if proc.returncode != 0 or self.service_name not in stdout.decode():
                raise RuntimeError(f"Service {self.service_name} non trouv√©")

            # V√©rifier que mpv est install√©
            proc = await asyncio.create_subprocess_exec(
                "which", "mpv",
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            await proc.wait()

            if proc.returncode != 0:
                raise RuntimeError("mpv n'est pas install√©")

            # Initialiser les composants
            await self.station_manager.initialize()

            # Pr√©charger les stations en arri√®re-plan (non-bloquant)
            asyncio.create_task(self._preload_stations())

            self.logger.info("Plugin Radio initialis√©")
            return True

        except Exception as e:
            self.logger.error(f"Erreur initialisation Radio: {e}")
            return False

    async def _preload_stations(self) -> None:
        """Pr√©charge les stations en arri√®re-plan"""
        try:
            self.logger.info("Pr√©chargement des stations...")
            await self.radio_api.load_all_stations()
            self.logger.info("Stations pr√©charg√©es avec succ√®s")
        except Exception as e:
            self.logger.error(f"Erreur pr√©chargement stations: {e}")

    async def _do_start(self) -> bool:
        """D√©marrage du service Radio"""
        try:
            # D√©marrer le service systemd (mpv)
            if not await self.control_service(self.service_name, "start"):
                return False

            # Attendre que le service soit pr√™t
            await asyncio.sleep(1)

            # V√©rifier que le service est actif
            is_active = await self.service_manager.is_active(self.service_name)
            if not is_active:
                self.logger.error("Service mpv d√©marr√© mais pas actif")
                return False

            # Connecter au socket IPC de mpv
            if not await self.mpv.connect(max_retries=10, retry_delay=0.5):
                self.logger.error("Impossible de se connecter au socket IPC mpv")
                return False

            # D√©marrer la surveillance de l'√©tat mpv
            self._stopping = False
            self._monitor_task = asyncio.create_task(self._monitor_playback())

            # Notifier √©tat READY
            await self.notify_state_change(PluginState.READY, {
                "ready": True,
                "mpv_connected": self.mpv.is_connected
            })

            self.logger.info("Service Radio d√©marr√© et pr√™t")
            return True

        except Exception as e:
            self.logger.error(f"Erreur d√©marrage Radio: {e}")
            return False

    async def restart(self) -> bool:
        """Red√©marre le service mpv"""
        try:
            self.logger.info("Red√©marrage du service Radio")

            # Arr√™ter la surveillance
            self._stopping = True
            if self._monitor_task:
                self._monitor_task.cancel()
                try:
                    await self._monitor_task
                except asyncio.CancelledError:
                    pass

            # D√©connecter mpv
            await self.mpv.disconnect()

            # Reset √©tat
            self.current_station = None
            self._is_playing = False
            self._is_buffering = False
            self._metadata = {}

            # Red√©marrer le service
            success = await self.control_service(self.service_name, "restart")

            if not success:
                self.logger.error(f"√âchec red√©marrage service {self.service_name}")
                return False

            # Attendre que le service soit pr√™t
            await asyncio.sleep(1)

            # Reconnexion IPC
            if not await self.mpv.connect(max_retries=10, retry_delay=0.5):
                self.logger.error("Impossible de se reconnecter au socket IPC apr√®s restart")
                return False

            # Red√©marrer la surveillance
            self._stopping = False
            self._monitor_task = asyncio.create_task(self._monitor_playback())

            # Notifier √©tat READY
            async def notify_ready_state():
                await asyncio.sleep(0.1)
                await self.notify_state_change(PluginState.READY, {"ready": True})

            asyncio.create_task(notify_ready_state())

            self.logger.info("Service Radio red√©marr√©")
            return True

        except Exception as e:
            self.logger.error(f"Erreur red√©marrage Radio: {e}")
            return False

    async def stop(self) -> bool:
        """Arr√™te le plugin Radio"""
        try:
            self.logger.info("Arr√™t du plugin Radio")

            # Arr√™ter la surveillance
            self._stopping = True
            if self._monitor_task:
                self._monitor_task.cancel()
                try:
                    await self._monitor_task
                except asyncio.CancelledError:
                    pass

            # Arr√™ter la lecture
            if self._is_playing:
                await self.mpv.stop()

            # D√©connecter mpv
            await self.mpv.disconnect()

            # Fermer l'API Radio Browser
            await self.radio_api.close()

            # Arr√™ter le service
            await self.control_service(self.service_name, "stop")

            # Reset √©tat
            self.current_station = None
            self._is_playing = False
            self._is_buffering = False
            self._metadata = {}

            await self.notify_state_change(PluginState.INACTIVE)
            self.logger.info("Plugin Radio arr√™t√©")
            return True

        except Exception as e:
            self.logger.error(f"Erreur arr√™t Radio: {e}")
            return False

    async def _monitor_playback(self) -> None:
        """
        Surveille l'√©tat de lecture de mpv

        V√©rifie p√©riodiquement l'√©tat et les m√©tadonn√©es
        """
        try:
            while not self._stopping:
                try:
                    # V√©rifier l'√©tat de lecture
                    is_playing = await self.mpv.is_playing()

                    # DEBUG: Logger l'√©tat brut de mpv (seulement pendant buffering)
                    if self.current_station and self._is_buffering:
                        playback_time = await self.mpv.get_property("playback-time")
                        self.logger.info(f"üîç Monitor: is_playing={is_playing}, playback_time={playback_time}")

                    # Mettre √† jour l'√©tat imm√©diatement (pas de debouncing avec core-idle)
                    if is_playing != self._is_playing:
                        self._is_playing = is_playing
                        self.logger.info(f"√âtat lecture chang√©: {'playing' if is_playing else 'stopped'}")

                        # Si on passe √† playing et qu'on √©tait en buffering, terminer le buffering
                        if is_playing and self._is_buffering:
                            self._is_buffering = False
                            self.logger.info("‚úÖ Buffering termin√©, stream en lecture")

                    # Le plugin_state est CONNECTED tant qu'une station est charg√©e
                    # isPlaying dans les m√©tadonn√©es indique l'√©tat r√©el de lecture
                    if self.current_station:
                        await self._update_metadata()

                        # Broadcast √† chaque update pour synchroniser tous les clients
                        await self.notify_state_change(PluginState.CONNECTED, self._metadata)

                    # Polling rapide pour d√©tecter rapidement le d√©but de la lecture
                    await asyncio.sleep(0.5)  # V√©rifier toutes les 0.5 secondes

                except Exception as e:
                    self.logger.error(f"Erreur surveillance lecture: {e}")
                    await asyncio.sleep(5)

        except asyncio.CancelledError:
            self.logger.debug("Surveillance lecture annul√©e")
        except Exception as e:
            self.logger.error(f"Erreur critique surveillance: {e}")

    async def _update_metadata(self) -> None:
        """Met √† jour les m√©tadonn√©es depuis mpv"""
        try:
            # V√©rifier que current_station est un dict AVANT d'acc√©der aux propri√©t√©s
            if self.current_station and not isinstance(self.current_station, dict):
                self.logger.error(f"current_station n'est pas un dict: {type(self.current_station)}, valeur: {self.current_station}")
                self.current_station = None
                self._metadata = {}
                return

            self._metadata = {
                "station_id": self.current_station.get('id') if self.current_station else None,
                "station_name": self.current_station.get('name') if self.current_station else None,
                "station_url": self.current_station.get('url') if self.current_station else None,
                "country": self.current_station.get('country') if self.current_station else None,
                "genre": self.current_station.get('genre') if self.current_station else None,
                "favicon": self.current_station.get('favicon') if self.current_station else None,
                "bitrate": self.current_station.get('bitrate') if self.current_station else None,
                "codec": self.current_station.get('codec') if self.current_station else None,
                "is_favorite": self.station_manager.is_favorite(
                    self.current_station.get('id')
                ) if self.current_station else False,
                "is_playing": self._is_playing,
                "buffering": self._is_buffering
            }

        except Exception as e:
            self.logger.error(f"Erreur mise √† jour m√©tadonn√©es: {e}", exc_info=True)

    async def handle_command(self, command: str, data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Traite les commandes du plugin

        Commandes support√©es:
            - play_station: Joue une station par ID
            - stop_playback: Arr√™te la lecture
            - add_favorite: Ajoute aux favoris
            - remove_favorite: Retire des favoris
            - mark_broken: Marque une station comme cass√©e
            - reset_broken: Reset les stations cass√©es
        """
        try:
            if command == "play_station":
                return await self._handle_play_station(data)

            elif command == "stop_playback":
                return await self._handle_stop_playback()

            elif command == "add_favorite":
                return await self._handle_add_favorite(data)

            elif command == "remove_favorite":
                return await self._handle_remove_favorite(data)

            elif command == "mark_broken":
                return await self._handle_mark_broken(data)

            elif command == "reset_broken":
                return await self._handle_reset_broken()

            return self.format_response(False, error=f"Commande non support√©e: {command}")

        except Exception as e:
            self.logger.error(f"Erreur traitement commande {command}: {e}")
            return self.format_response(False, error=str(e))

    async def _handle_play_station(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Joue une station radio"""
        station_id = data.get('station_id')
        if not station_id:
            self.logger.error("‚ùå Commande play_station sans station_id")
            return self.format_response(False, error="station_id requis")

        try:
            # R√©cup√©rer la station
            station = await self.radio_api.get_station_by_id(station_id)
            if not station:
                self.logger.error(f"‚ùå Station introuvable: {station_id}")
                return self.format_response(False, error=f"Station {station_id} introuvable")

            self.logger.info(f"üìª Lecture de la station: {station['name']} (URL: {station['url']})")

            # Incr√©menter compteur Radio Browser
            asyncio.create_task(self.radio_api.increment_station_clicks(station_id))

            # Mettre √† jour l'√©tat : buffering en cours
            self.current_station = station
            self._is_playing = False
            self._is_buffering = True
            await self._update_metadata()

            # Notifier imm√©diatement l'√©tat de buffering
            await self.notify_state_change(PluginState.CONNECTED, self._metadata)

            # Charger le stream dans mpv
            success = await self.mpv.load_stream(station['url'])

            if not success:
                # Marquer comme cass√©e et reset buffering
                self._is_buffering = False
                self.current_station = None
                await self.station_manager.mark_as_broken(station_id)
                self.logger.error(f"‚ùå Impossible de charger le stream: {station['name']} ({station['url']})")
                return self.format_response(
                    False,
                    error=f"Impossible de charger le stream {station['name']}"
                )

            # Le buffering continuera jusqu'√† ce que _monitor_playback d√©tecte is_playing=true
            # On ne met pas _is_playing = True ici, on laisse _monitor_playback le faire

            return self.format_response(
                True,
                message=f"Chargement de {station['name']}",
                station=station
            )

        except Exception as e:
            self.logger.error(f"Erreur lecture station: {e}")
            self._is_buffering = False
            return self.format_response(False, error=str(e))

    async def _handle_stop_playback(self) -> Dict[str, Any]:
        """Arr√™te la lecture"""
        try:
            # Toujours arr√™ter mpv (ignore l'erreur si d√©j√† arr√™t√©)
            await self.mpv.stop()

            # Toujours reset l'√©tat, m√™me si mpv retourne une erreur
            # (cas o√π on appelle stop() alors qu'on est d√©j√† arr√™t√©)
            self.current_station = None
            self._is_playing = False
            self._is_buffering = False

            # Cr√©er des m√©tadonn√©es avec is_playing: false pour notifier le frontend
            self._metadata = {
                "is_playing": False,
                "buffering": False,
                "ready": True
            }

            await self.notify_state_change(PluginState.READY, self._metadata)

            return self.format_response(
                True,
                message="Lecture arr√™t√©e"
            )

        except Exception as e:
            return self.format_response(False, error=str(e))

    async def _handle_add_favorite(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Ajoute une station aux favoris"""
        station_id = data.get('station_id')
        if not station_id:
            return self.format_response(False, error="station_id requis")

        success = await self.station_manager.add_favorite(station_id)
        return self.format_response(
            success,
            message="Station ajout√©e aux favoris" if success else "√âchec ajout favori"
        )

    async def _handle_remove_favorite(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Retire une station des favoris"""
        station_id = data.get('station_id')
        if not station_id:
            return self.format_response(False, error="station_id requis")

        success = await self.station_manager.remove_favorite(station_id)
        return self.format_response(
            success,
            message="Station retir√©e des favoris" if success else "√âchec retrait favori"
        )

    async def _handle_mark_broken(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Marque une station comme cass√©e"""
        station_id = data.get('station_id')
        if not station_id:
            return self.format_response(False, error="station_id requis")

        success = await self.station_manager.mark_as_broken(station_id)
        return self.format_response(
            success,
            message="Station marqu√©e comme cass√©e" if success else "√âchec marquage"
        )

    async def _handle_reset_broken(self) -> Dict[str, Any]:
        """Reset les stations cass√©es"""
        success = await self.station_manager.reset_broken_stations()
        return self.format_response(
            success,
            message="Stations cass√©es r√©initialis√©es" if success else "√âchec reset"
        )

    async def get_status(self) -> Dict[str, Any]:
        """R√©cup√®re l'√©tat actuel du plugin"""
        try:
            service_status = await self.service_manager.get_status(self.service_name)
            mpv_status = await self.mpv.get_status()
            stats = self.station_manager.get_stats()

            return {
                "service_active": service_status.get("active", False),
                "mpv_connected": mpv_status.get("connected", False),
                "is_playing": self._is_playing,
                "current_station": self.current_station,
                "metadata": self._metadata,
                "current_device": self._current_device,
                "favorites_count": stats['favorites_count'],
                "broken_stations_count": stats['broken_stations_count']
            }

        except Exception as e:
            self.logger.error(f"Erreur status: {e}")
            return {
                "service_active": False,
                "mpv_connected": False,
                "is_playing": False,
                "current_station": None,
                "metadata": {},
                "current_device": self._current_device,
                "error": str(e)
            }

    async def get_initial_state(self) -> Dict[str, Any]:
        """√âtat initial pour les WebSockets"""
        return await self.get_status()
