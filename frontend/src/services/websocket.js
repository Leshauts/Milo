// frontend/src/services/websocket.js
/**
 * Service pour gÃ©rer la connexion WebSocket avec reconnexion automatique amÃ©liorÃ©e
 */
import { ref, onUnmounted } from 'vue';

// Identifiant unique pour cette instance
const CLIENT_ID = 'frontend-' + Date.now();
const DEBUG = true;

export default function useWebSocket() {
  const socket = ref(null);
  const isConnected = ref(false);
  const lastMessage = ref(null);
  const events = {};
  const connectionAttempts = ref(0);
  let reconnectTimer = null;

  // Fonction pour crÃ©er une nouvelle connexion
  const createNewConnection = () => {
    // DÃ©terminer l'URL WebSocket en fonction de l'environnement
    let wsUrl;

    if (import.meta.env.DEV) {
      // En dÃ©veloppement, utiliser l'hÃ´te du navigateur
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const host = window.location.hostname;
      const port = 8000; // Port du backend
      wsUrl = `${protocol}//${host}:${port}/ws`;

      console.log(`ðŸ”Œ Connexion WebSocket en mode dÃ©veloppement Ã  ${wsUrl}`);
    } else {
      // En production, utiliser l'API proxy
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      wsUrl = `${protocol}//${window.location.host}/ws`;

      console.log(`ðŸ”Œ Connexion WebSocket en mode production Ã  ${wsUrl}`);
    }

    // Annuler toute tentative de reconnexion en cours
    if (reconnectTimer) {
      clearTimeout(reconnectTimer);
      reconnectTimer = null;
    }

    try {
      // Nettoyer la connexion prÃ©cÃ©dente si elle existe
      if (socket.value && socket.value.readyState !== WebSocket.CLOSED) {
        try {
          socket.value.close();
        } catch (e) {
          console.warn('Erreur lors de la fermeture du WebSocket:', e);
        }
      }

      // CrÃ©er la nouvelle instance WebSocket
      socket.value = new WebSocket(wsUrl);

      socket.value.onopen = () => {
        console.log('âœ… WebSocket connectÃ© avec succÃ¨s');
        isConnected.value = true;
        connectionAttempts.value = 0;

        // Envoyer un message initial pour Ã©tablir la communication
        socket.value.send(JSON.stringify({
          type: 'client_connected',
          data: {
            client_id: CLIENT_ID,
            timestamp: Date.now(),
            user_agent: navigator.userAgent
          }
        }));

        // Configurer le heartbeat
        startHeartbeat();
      };

      socket.value.onmessage = (event) => {
        try {
          const message = JSON.parse(event.data);

          // Ne pas logger les pings pour rÃ©duire le bruit
          if (message.type !== 'ping' && message.type !== 'heartbeat_ack') {
            // Log spÃ©cial pour les Ã©vÃ©nements Snapclient
            if (message.type && message.type.startsWith('snapclient_')) {
              if (DEBUG) {
                console.log(`âš¡ WebSocket reÃ§u [${message.type}]:`, message.data);
              }
            }
          }

          lastMessage.value = message;

          // Traitement spÃ©cial pour certains types de messages
          if (message.type === 'ping') {
            // RÃ©pondre avec un pong pour maintenir la connexion
            socket.value.send(JSON.stringify({
              type: 'pong',
              data: { timestamp: Date.now() }
            }));
            return; // Ne pas propager les pings
          }

          // AMÃ‰LIORATION: Traitement prioritaire et immÃ©diat des messages critiques
          const criticalEvents = [
            'snapclient_monitor_disconnected',
            'snapclient_server_disappeared',
            'audio_status_updated'
          ];

          if (criticalEvents.includes(message.type)) {
            console.log(`ðŸš¨ Message WebSocket CRITIQUE reÃ§u: ${message.type}`);

            // ExÃ©cution prioritaire des callbacks pour les messages critiques
            if (events[message.type]) {
              events[message.type].forEach(callback => {
                try {
                  // ExÃ©cuter immÃ©diatement, sans aucun dÃ©lai
                  callback(message.data);
                } catch (e) {
                  console.error(`Erreur dans callback de ${message.type}:`, e);
                }
              });
            }
          }
          else {
            // DÃ©clencher les Ã©couteurs d'Ã©vÃ©nements standards pour les Ã©vÃ©nements non-critiques
            if (message.type && events[message.type]) {
              events[message.type].forEach(callback => {
                try {
                  callback(message.data);
                } catch (callbackError) {
                  console.error(`Erreur dans callback de ${message.type}:`, callbackError);
                }
              });
            }
          }
        } catch (error) {
          console.error('Erreur de parsing WebSocket:', error);
        }
      };

      socket.value.onclose = (event) => {
        console.log(`WebSocket dÃ©connectÃ©, code: ${event.code}, raison: ${event.reason || 'inconnue'}`);
        isConnected.value = false;
        clearHeartbeat();

        // Ne pas tenter de reconnexion si c'est une fermeture propre initiÃ©e par l'utilisateur
        if (event.code === 1000 && event.reason === "DÃ©montage propre") {
          console.log("Fermeture propre, pas de reconnexion automatique");
          return;
        }

        // IncrÃ©menter le compteur de tentatives
        connectionAttempts.value++;

        // DÃ©lai exponentiel pour les reconnexions (max 30 secondes)
        const delay = Math.min(30000, Math.pow(1.5, Math.min(connectionAttempts.value, 10)) * 1000);
        console.log(`Tentative de reconnexion dans ${(delay / 1000).toFixed(1)}s (tentative #${connectionAttempts.value})`);

        // Tenter de se reconnecter aprÃ¨s un dÃ©lai
        reconnectTimer = setTimeout(() => {
          console.log("Tentative de reconnexion...");
          createNewConnection();
        }, delay);
      };

      socket.value.onerror = (error) => {
        console.error('Erreur WebSocket:', error);
        // La gestion des erreurs est maintenant dÃ©lÃ©guÃ©e Ã  onclose
      };
    } catch (e) {
      console.error("Erreur lors de la crÃ©ation du WebSocket:", e);
      // En cas d'erreur, planifier une nouvelle tentative
      reconnectTimer = setTimeout(() => {
        console.log("Nouvelle tentative aprÃ¨s erreur...");
        createNewConnection();
      }, 3000);
    }
  };

  // Heartbeat pour maintenir la connexion active
  let heartbeatInterval = null;

  const startHeartbeat = () => {
    // Nettoyer l'ancien heartbeat si existant
    clearHeartbeat();

    // Configurer un nouveau heartbeat
    heartbeatInterval = setInterval(() => {
      if (socket.value && socket.value.readyState === WebSocket.OPEN) {
        try {
          socket.value.send(JSON.stringify({
            type: 'heartbeat',
            data: {
              timestamp: Date.now(),
              client_id: CLIENT_ID
            }
          }));
        } catch (e) {
          console.error("Erreur d'envoi de heartbeat:", e);
          // Si l'envoi Ã©choue, tenter de reconnecter
          isConnected.value = false;
          clearHeartbeat();
          createNewConnection();
        }
      } else if (socket.value && socket.value.readyState !== WebSocket.CONNECTING) {
        // Si le socket n'est pas en train de se connecter et n'est pas ouvert, reconnecter
        console.warn("Heartbeat: WebSocket n'est pas ouvert, tentative de reconnexion");
        isConnected.value = false;
        clearHeartbeat();
        createNewConnection();
      }
    }, 20000); // 20 secondes, rÃ©duit de 30s pour Ãªtre plus rÃ©actif
  };

  const clearHeartbeat = () => {
    if (heartbeatInterval) {
      clearInterval(heartbeatInterval);
      heartbeatInterval = null;
    }
  };

  const connect = () => {
    createNewConnection();
  };

  const on = (eventType, callback) => {
    if (!events[eventType]) {
      events[eventType] = [];
    }
    events[eventType].push(callback);

    // Retourner une fonction pour se dÃ©sabonner
    return () => {
      if (events[eventType]) {
        events[eventType] = events[eventType].filter(cb => cb !== callback);
      }
    };
  };

  const send = (data) => {
    if (socket.value && socket.value.readyState === WebSocket.OPEN) {
      try {
        socket.value.send(JSON.stringify(data));
        return true;
      } catch (e) {
        console.error("Erreur d'envoi WebSocket:", e);
        // Tenter de reconnecter en cas d'erreur
        isConnected.value = false;
        createNewConnection();
        return false;
      }
    } else {
      console.warn("WebSocket non connectÃ©, impossible d'envoyer:", data);
      // Tenter de reconnecter
      if (!isConnected.value) {
        console.log("Tentative de reconnexion aprÃ¨s Ã©chec d'envoi");
        createNewConnection();
      }
      return false;
    }
  };

  // Fonction de nettoyage pour la dÃ©connexion
  const cleanup = () => {
    if (reconnectTimer) {
      clearTimeout(reconnectTimer);
      reconnectTimer = null;
    }

    if (socket.value) {
      clearHeartbeat();

      // Fermeture propre
      try {
        if (socket.value.readyState === WebSocket.OPEN) {
          socket.value.close(1000, "DÃ©montage propre");
        }
      } catch (e) {
        console.warn("Erreur lors de la fermeture du WebSocket:", e);
      }

      socket.value = null;
    }

    isConnected.value = false;
  };

  // VÃ©rification pÃ©riodique de la connexion
  let connectionCheckInterval = null;

  const startConnectionCheck = () => {
    connectionCheckInterval = setInterval(() => {
      if (!isConnected.value && !reconnectTimer) {
        console.log("VÃ©rification: WebSocket dÃ©connectÃ©, tentative de reconnexion");
        createNewConnection();
      }
    }, 10000); // 10 secondes
  };

  // Nettoyer la connexion quand le composant est dÃ©montÃ©
  onUnmounted(() => {
    if (connectionCheckInterval) {
      clearInterval(connectionCheckInterval);
    }
    cleanup();
  });

  // Connexion initiale
  connect();
  startConnectionCheck();

  return {
    isConnected,
    lastMessage,
    on,
    send,
    reconnect: connect,
    disconnect: cleanup
  };
}